---
layout: post
title:  "스프링 웹 소켓 알아보기(4)"
date:   2024-11-22 20:08:06 +0900
categories: 스프링
excerpt_separator: <!--more-->
toc: true
---
이번 포스팅부터는 STOMP에 대하여 알아보자
<!--more-->
앞선 포스팅에서 알아보았듯, WebSocket은 HTTP와 달리 메시지의 **구조나 의미(semantics)**에 대한 표준화된 규약이 없다.<br>
따라서 WebSocket을 사용할 때, 클라이언트와 서버가 주고받을 메시지의 형식과 내용을 직접 정의해야 한다.
<br><br>
하지만 이렇게 모든 메시지의 규칙을 직접 구현하는 것은 복잡하고 번거롭다.
이를 해결하기 위해 등장한 것이 바로 **STOMP(Simple/Streaming Text Oriented Messaging Protocol)**다.<br>
STOMP는 WebSocket 위에서 동작하며, 메시지의 형식과 의미를 표준화하여 메시징을 간단하고 효율적으로 처리할 수 있도록 도와준다.

### STOMP 프레임 구조
STOMP는 HTTP를 모델로 한 프레임 기반 프로토콜이다.
```text
COMMAND
header1:value1
header2:value2

Body^@
```
* COMMAND : 실행할 명령(SEND, SUBSCRIBE 등)
* 헤더 : 메시지의 속성과 목적지를 지정
* Body : 메시지 내용

클라이언트는 `SEND` 또는 `SUBSCRIBE` 명령을 사용하여 메시지를 보내거나 구독할 수 있다. 이 메시지는 브로커를 통해 다른 연결된 클라이언트에게 메시지를 보내거나, 서버에 메시지를 보내 작업을 수행하도록 요청할 수 있다.<br>
이게 간단한 pub/sub 메커니즘이다.

### Spring에서의 STOMP
* 스프링의 STOMP 지원을 활성화하면 스프링 애플리케이션이 STOMP 브로커 역할을 한다. 
* 메시지를 `@Controller`의 메시지 핸들링 메서드로 라우팅하거나, 간단한 메모리 브로커를 통해 구독자에게 브로드캐스트한다.
* RabbitMQ, ActiveMQ 같은 외부 STOMP 브로커와 통합 가능
* Spring은 브로커와의 TCP 연결을 유지하며, 메시지를 중계하거나 WebSocket 클라이언트와 교환

### STOMP 예시
공식문서에 있는 예시를 통해 이해해보자.<br>
아래는 주식시세를 주기적으로 가져오는 서버에 클라이언트가 구독하는 예시이다.<br>

#### 1. 구독 요청(클라이언트 -> 서버)
```
SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*
^@
```
* 클라이언트는 `/topic/price.stock.*`경로의 메시지를 수신하도록 요청

---

#### 2. 메시지 전송 (클라이언트 -> 서버)

```
SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@
```

* 클라이언트가 서버에 주식 구매 요청을 보냄
* 서버는 `@MessageMapping` 메서드를 통해 이를 처리

---

#### 3. 메시지 브로드캐스트(서버 -> 클라이언트)

```
MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@
```

* 서버가 `/topic/price.stock.MMM`을 구독한 클라이언트에게 주식 가격 메시지를 전달

#### STOMP의 destination
STOMP에서는 목적지의 의미가 명확하게 정해져 있지 않으며 서버에서 정의한다.
* 일반적인 패턴
    * `/topic/..` : Publish-Subscribe(1:N)
    * `/queue/..` : Point-to-Point(1:1)

#### 제한사항
* 서버는 구독 요청이 없는 경우 메시지를 전송할 수 없다.
* 서버에서 보낸 메시지는 항상 특정 클라이언트 구독과 연관되어야 한다.

### Spring에서 STOMP 활성화
스프링에서는 WebSocket 위에서 STOMP를 사용하는 기능을 제공한다.<br>
STOMP는 `spring-messaging` 및 `spring-websocket` 모듈에서 제공한다.<br>
사용하는 공식문서 예제를 보자.
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfiguration implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // 클라이언트가 WebSocket 핸드셰이크를 요청할 URL
        registry.addEndpoint("/portfolio");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // "/app"으로 시작하는 메시지는 @Controller의 @MessageMapping 메서드로 라우팅
        config.setApplicationDestinationPrefixes("/app");

        // /topic 또는 /queue로 시작하는 메시지는 내장 브로커로 전송
        config.enableSimpleBroker("/topic", "/queue");
    }
}
```
* Spring에서 STOMP 지원을 활성화하려면
`@EnableWebSocketMessageBroker`를 사용하면 된다.
주석을 확인하면 이해하기 쉬울 것이다.만약 외부 브로커를 사용할 경우 브로커가 지원하는 STOMP 목적지와 접두사를 확인해야한다.