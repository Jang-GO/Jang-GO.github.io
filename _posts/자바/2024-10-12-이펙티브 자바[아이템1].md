---
layout: post
title:  "이펙티브 자바[아이템1]"
date:   2024-10-12 22:10:06 +0900
categories: 이펙티브 자바
excerpt_separator: <!--more-->
toc: true
---
## 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라.
<!--more-->
이번 아이템의 제목은 생성자로 객체를 생성하는 것과 더불어 static 객체 생성 메서드를 고려하라는 것이다. 왜 그럴까?

### 장점1. 이름을 가질 수 있다.
<b>기본적으로 자바에서는 시그니처가 동일한 생성자를 두 개 이상 만들 수 없다.<b>

```java
public class Order {
    private boolean prime;

    private boolean urgent;

    private Product product;

    public Order(Product product, boolean prime){
        this.product = product;
        this.prime = prime;
    }
    public Order(Product product, boolean urgent){
        this.product = product;
        this.urgent = urgent;
    }
}
```
* urgent와 prime필드가 둘다 `boolean`타입으로 동일하여 생성자 시그니처가 동일하다.
* 따라서 위 코드는 컴파일 에러가 발생한다.
* 또한 생성자는 이름이 없기 때문에 어떤 객체가 만들어지는지 파악하기 불리하다.

위와 같은 이유로 정적 팩토리 메서드를 만들어 객체 생성을 분리하면 아래와 같다.
```java
public class Order {
    private boolean prime;

    private boolean urgent;

    private Product product;

    public static Order primeOrder(Product product){
        Order order = new Order();
        order.prime = true;
        order.product = product;
        return order;
    }
    public static Order urgentOrder(Product product){
        Order order = new Order();
        order.urgent = true;
        order.product = product;
        return order;
    }
}
```
* prime, urgent 필드를 각각 지정하여 생성하는  정적 팩터리 메서드를 만들었다.
* 따라서 생성자의 시그니처가 동일한 경우 객체 생성에 용이하다.
* 메서드 이름으로 어떤 객체가 만들어지는지 알아보기 좋다.

### 장점2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
<b> 자바의 생성자는 매번 호출될 때마다 새로운 인스턴스를 만든다.<br>

```java
public class Settings {
    private boolean useAutoSteering;
    private boolean useABS;
    private Difficulty difficulty;

    public static void main(String[] args){
        System.out.println(new Settings());
        System.out.println(new Settings());
        System.out.println(new Settings());
    }
}

// 출력
chap1.item1.Settings@776ec8df
chap1.item1.Settings@4eec7777
chap1.item1.Settings@3b07d329
```
* 인스턴스가 만들어지는 것을 통제할 수 없다.
* 즉, 어디서든 인스턴스가 생성되는걸 막지 못한다.

여기서 정적 팩터리 메서드와 private 생성자로 무분별한 객체 생성을 방지할 수 있다.
```java
public class Settings {
    private boolean useAutoSteering;
    private boolean useABS;
    private Difficulty difficulty;

    private Settings(){}

    private final static Settings SETTINGS = new Settings();

    public static Settings newInstance(){
        return SETTINGS;
    }
}
```
* 생성자를 public으로 열어두는 순간부터 인스턴스를 컨트롤할 수 없다.
* 이제 다른 클래스에서는 정적 팩터리 메서드를 통하여만 인스턴스를 받아갈 수 있다.

아래는 `Boolean.valueOf()` 메서드의 구현 코드이다.
```java
...
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
...
@IntrinsicCandidate
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```
* Boolean 클래스의 valueOf() 메서드 또한 파라미터에 따라서 미리 정의된 TRUE, FALSE 상수를 리턴한다.
* 정적 팩터리 메서드를 이용하면 파라미터에 따라 다른 객체를 리턴하기 좋다.

### 장점3,4 . 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
생성자를 이용하면 해당하는 클래스의 인스턴스만 생성할 수 있다.<br>
<b>그러나 정적 팩터리 메서드는 인터페이스를 리턴할 수 있으며 즉, 인터페이스의 하위 타입도 리턴할 수 있다는 뜻이다.</b>
<br>
<b>따라서 유연하게 객체를 생성할 수 있는 장점이 있다.</b>

```java
public interface HelloService {
    String hello();

    static HelloService of(String lang){
        if(lang.equals("ko")){
            return new KoreanHelloService();
        }else{
            return new EnglishHelloService();
        }
    }
}

```
* 자바 8이후, 인터페이스에도 정적 메서드를 만들 수 있다.
* 따라서 xxxFactory클래스를 따로 만들 필요는 없다.

이후 아래와 같이 사용할 수 있다.
```java
public class HelloServiceFactory{
    public static void main(String[] args) {
        HelloService eng = HelloService.of("eng");
        System.out.print(eng.hello());
    }
}

// 출력
hello
```

### 장점 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다
아래와 같이 인터페이스만 있고 구현체가 존재하지 않는다고 가정해보자.
```java
public interface HelloService {
    String hello();
}
```
이후 아래 코드를보자.
```java
public class HelloServiceFactory{
    public static void main(String[] args) {
        ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);
        Optional<HelloService> helloServiceOptional = loader.findFirst();
        helloServiceOptional.ifPresent( h -> {
            System.out.println(h.hello());
        });
    }
}
```
* 자바에서는 `ServiceLoader.load()`라는 classpath내에 있는 구현체를 불러오는 정적 메서드를 제공한다.
* `ServiceLoader`는 ServiceProvider 프레임워크의 자바 기본 구현체이다.
