---
layout: post
title:  "프로젝트[01] #2 요구사항 분석 및 기능 설계"
date:   2024-08-15 14:01:06 +0900
categories: 프로젝트[01]
excerpt_separator: <!--more-->
---
<b>프로젝트[01] #2 요구사항 분석 및 엔티티 설계</b>
<!--more-->
일단 간단한 게시판을 만들기로 하였으니 게시판에 맞는 요구사항을 작성해보자.<br>

### 요구사항
* 게시글 작성
* 게시글 목록 조회
* 게시글 상세 조회
* 게시글 수정 및 삭제

위 4가지먼저 간단하게 개발해보자.
(개발 전 브랜치 생성 잊지않기)

```
git checkout -b feature/create-article
```
이후 각각 브랜치에서 기능 구현 후 테스트코드 작성까지 마친 후 PR을 날리는 방식으로 순차적으로 구현해나갈 예정이다.<br><br>

> 이번 챕터인 메모리맵 기반의 코드작성은 각 레이어별 요청 흐름 작성이 주요 목표이고 선택과 집중의 주요 대상이 아니므로 코드만 작성하고 넘어가도록 하려고 한다.

### 게시글 엔티티 요소
먼저 게시판이 가져야할 요소를 포함하여 엔티티를 만들어보자.<br>
필자는 벨로그를 참조하여 엔티티가 포함가능한 요소를 추려보았다.
* 제목
* 작성자
* 작성일 및 수정일
* 좋아요
* 사진 및 파일업로드

작성자와 좋아요같은 경우엔 사용자 정보가 필요하므로 로그인 및 회원가입 기능 구현 후에 구현하도록 하자.<br>
사진 및 파일업로드의 경우도 저장방식, 위치등을 고려해야 하므로 핵심기능인 게시판의 기능을 먼저 구현한 후 구현할 예정이다.<br><br>
따라서 
1. 게시판 핵심기능 구현 
2. DB접근기술
3. 사용자 인증 및 권한 관리 
4. 작성자 및 좋아요 필드 추가 
5. 사진 및 파일 업로드 

위의 순서대로 진행을 하면 좋을것 같다.

### 게시글 엔티티
위의 내용에 따라 domain 패키지 생성 후 `Article`이라는 게시글 클래스를 생성하였다.
* Post라는 단어가 있지만 Http메소드 POST와 혼동될 수 있어서 Article이라는 변수명을 선택하였다.

><b>패키지 구조</b><br>
> 패키지 구조는 크게 레이어 계층형과 도메인형으로 구분할 수 있다.<br>
* 레이어 계층형 : 계층별로 코드를 모아놓은 구조
* 도메인형 : 도메인별로 패키지를 나누고 패키지 내부에서 계층별로 모아놓은 구조

> 도메인형이 디렉터리 기준으로 관련코드를 모아놓기 때문에 응집도가 높아 보인다.<br>
필자는 개인프로젝트이기 때문에 익숙하며 좀더 구조가 간단한 레이어 계층형 패키지구조를 사용할 예정이다.<br>
이 부분에 관해서는 팀프로젝트에서 팀과 논의하여 결정하는 것이 좋아보인다.

##### Article 엔티티

```java
@Getter
public class Article {
    private Long id;
    private String title;
    private String content;
    private LocalDateTime createdDateTime;
    private LocalDateTime modifiedDateTime;

    public Article(Long id, String title, String content) {
        this(title, content);
        this.id = id;
    }
    public Article(String title, String content) {
        this.title = title;
        this.content = content;
        this.createdDateTime = LocalDateTime.now();
        this.modifiedDateTime = this.createdDateTime;
    }
}


```
기본적으로 처음 객체를 생성할때 수정시간은 생성시간과 동일하도록 생성하였다.<br>
다음에는 메모리맵을 활용해서 CRUD작업이 수행되는 Repository를 생성해보자.<br>
```java
public interface ArticleRepository {
    Article save(Article article);
    Optional<Article> findById(Long id);
    List<Article> findAll();
    void deleteById(Long id);
}
```
<br>

```java
@Repository
public class InMemoryArticleRepository implements ArticleRepository{
    private final ConcurrentHashMap<Long, Article> storage = new ConcurrentHashMap<>();
    private final AtomicLong sequence = new AtomicLong(1);
    @Override
    public Article save(Article article) {
        Long newId = sequence.getAndIncrement();
        Article newArticle = new Article(newId, article.getTitle(), article.getContent());
        storage.put(newId, newArticle);
        return newArticle;
    }

    @Override
    public Optional<Article> findById(Long id) {
        return Optional.ofNullable(storage.get(id));
    }

    @Override
    public List<Article> findAll() {
        return new ArrayList<>(storage.values());
    }

    @Override
    public void deleteById(Long id) {
        storage.remove(id);
    }
}
```
`clear` 메소드는 teardown을 위한 메소드이다.<br>
##### Service
```java
@Service
@RequiredArgsConstructor
public class ArticleService {
    private final ArticleRepository articleRepository;

    public Article createArticle(String title, String content){
        Article newArticle = new Article(title, content);
        return articleRepository.save(newArticle);
    }

    public Article findArticleById(Long id){
        Optional<Article> article = articleRepository.findById(id);
        return article.orElse(null);
    }

    public List<Article> findAllArticles(){
        return articleRepository.findAll();
    }

    public void deleteArticle(Long id){
        articleRepository.deleteById(id);
    }
}

```
`@RequiredArgsConstructor`는 final필드를 기준으로 생성자를 자동 생성해준다.<br>
만약 나중에 주입받아야할 의존성이 많아진다면 코드작성시간을 줄여주므로 기억해두자.<br>

##### Controller
```java
@RestController
@RequestMapping("/articles")
@RequiredArgsConstructor
public class ArticleController {

    private final ArticleService articleService;

    @PostMapping
    public ResponseEntity<Article> createArticle(@RequestBody ArticleCreateDto articleCreateDto){
        Article article = articleService.createArticle(articleCreateDto.getTitle(), articleCreateDto.getContent());
        return ResponseEntity.status(HttpStatus.CREATED).body(article);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Article> getArticleById(@PathVariable("id") Long id){
        Article article = articleService.findArticleById(id);
        return ResponseEntity.status(HttpStatus.OK).body(article);
    }

    @GetMapping
    public ResponseEntity<List<Article>> getAllArticles(){
        List<Article> articles = articleService.findAllArticles();
        return ResponseEntity.ok(articles);
    }
    @DeleteMapping("/{id}")
    public ResponseEntity<String> deleteArticle(@PathVariable Long id){
        articleService.deleteArticle(id);
        return ResponseEntity.ok(String.format("%s 게시글 삭제 완료", id));
    }
}
```
`createArticle`에서는 Article의 내용을 JSON형태로 받아오기 때문에 `@RequestBody`를 통해 JSON메시지를 Java객체로 매핑시킨다.<br>
그 역할을 해주는 것이 `ArticleCreateDto`이다.
```java
@Data
public class ArticleCreateDto {
    private String title;
    private String content;
}
```
이 챕터의 코드구현은 이정도로 마무리하려고 한다.<br>
여기서 더욱 작성하는건 오버헤드라고 생각하기 때문에 튜토리얼을 클리어했다고 생각하자.<br><br>
다음 챕터부터는 데이터 접근기술을 적용시켜볼 예정이다.<br>
필자는 `MyBatis`와 `JPA` 두 버전의 코드를 작성하고 비교해보자.